{
  "puppet_classes": [
    {
      "name": "prometheus",
      "file": "manifests/init.pp",
      "line": 1,
      "inherits": "::prometheus::params",
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "systemd_path"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "namespace"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Optional[Enum['etcd','master','worker']]"
            ],
            "name": "role"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Any"
            ],
            "name": "etcd_cluster"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer[1025,65535]"
            ],
            "name": "etcd_k8s_main_port"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer[1025,65535]"
            ],
            "name": "etcd_k8s_events_port"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer[1024,65535]"
            ],
            "name": "etcd_overlay_port"
          }
        ]
      },
      "defaults": {
        "systemd_path": "'/etc/systemd/system'",
        "namespace": "'monitoring'",
        "role": "$::prometheus::params::role",
        "etcd_cluster": "$::prometheus::params::etcd_cluster",
        "etcd_k8s_main_port": "$::prometheus::params::etcd_k8s_main_port",
        "etcd_k8s_events_port": "$::prometheus::params::etcd_k8s_events_port",
        "etcd_overlay_port": "$::prometheus::params::etcd_overlay_port"
      },
      "source": "class prometheus(\n  String $systemd_path = '/etc/systemd/system',\n  String $namespace = 'monitoring',\n  Optional[Enum['etcd','master','worker']] $role = $::prometheus::params::role,\n  $etcd_cluster = $::prometheus::params::etcd_cluster,\n  Integer[1025,65535] $etcd_k8s_main_port = $::prometheus::params::etcd_k8s_main_port,\n  Integer[1025,65535] $etcd_k8s_events_port = $::prometheus::params::etcd_k8s_events_port,\n  Integer[1024,65535] $etcd_overlay_port = $::prometheus::params::etcd_overlay_port,\n) inherits ::prometheus::params\n{\n\n  if $role == 'master' {\n    include ::prometheus::server\n    include ::prometheus::kube_state_metrics\n    include ::prometheus::node_exporter\n    include ::prometheus::blackbox_exporter\n    include ::prometheus::blackbox_exporter_etcd\n  }\n\n  if $role == 'etcd' {\n    include ::prometheus::node_exporter\n    include ::prometheus::blackbox_exporter_etcd\n  }\n\n}"
    },
    {
      "name": "prometheus::blackbox_exporter",
      "file": "manifests/blackbox_exporter.pp",
      "line": 2,
      "docstring": {
        "text": "Sets up a blackbox exporter to blackbox probe in-cluster services and pods",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "port"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "replicas"
          }
        ]
      },
      "defaults": {
        "image": "'prom/blackbox-exporter'",
        "version": "'0.12.0'",
        "port": "9115",
        "replicas": "2"
      },
      "source": "class prometheus::blackbox_exporter(\n  String $image = 'prom/blackbox-exporter',\n  String $version = '0.12.0',\n  Integer $port = 9115,\n  Integer $replicas = 2,\n)\n{\n  include ::prometheus\n  $namespace = $::prometheus::namespace\n\n  # Setup deployment for blackbox exporter in cluster\n  if $::prometheus::role == 'master' {\n    kubernetes::apply{'blackbox-exporter':\n      manifests => [\n        template('prometheus/prometheus-ns.yaml.erb'),\n        template('prometheus/blackbox-exporter-deployment.yaml.erb'),\n        template('prometheus/blackbox-exporter-svc.yaml.erb'),\n      ],\n    }\n  }\n}"
    },
    {
      "name": "prometheus::blackbox_exporter_etcd",
      "file": "manifests/blackbox_exporter_etcd.pp",
      "line": 2,
      "docstring": {
        "text": "exporter_# Sets up a blackbox exporter to forward etcd metrics from etcd nodes",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "download_url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "config_dir"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "port"
          }
        ]
      },
      "defaults": {
        "download_url": "'https://github.com/jetstack-experimental/blackbox_exporter/releases/download/v#VERSION#/blackbox_exporter_#VERSION#_linux_amd64'",
        "version": "'0.4.0-jetstack'",
        "config_dir": "'/etc/blackbox_exporter'",
        "port": "9115"
      },
      "source": "class prometheus::blackbox_exporter_etcd (\n  String $download_url = 'https://github.com/jetstack-experimental/blackbox_exporter/releases/download/v#VERSION#/blackbox_exporter_#VERSION#_linux_amd64',\n  String $version = '0.4.0-jetstack',\n  String $config_dir = '/etc/blackbox_exporter',\n  Integer $port = 9115,\n)\n{\n  include ::prometheus\n\n  $dest_dir = \"/opt/blackbox_exporter-${version}\"\n  $systemd_path = $::prometheus::systemd_path\n\n  $etcd_k8s_main_port = $::prometheus::etcd_k8s_main_port\n  $etcd_k8s_events_port = $::prometheus::etcd_k8s_events_port\n  $etcd_overlay_port = $::prometheus::etcd_overlay_port\n\n  # Setup scrapes and rules for blackbox_etcd\n  if $::prometheus::role == 'master' {\n    include ::prometheus::server\n\n    $blackbox_exporters = $::prometheus::etcd_cluster.map |$node| { \"${node}:${port}\" }\n\n    prometheus::scrape_config { 'etcd-k8s-main':\n      order  =>  140,\n      config => {\n        'metrics_path'    => '/probe',\n        'params'          => { 'module' => ['etcd_k8s_main_proxy'] },\n        'static_configs'  => [{\n          'targets' => $blackbox_exporters,\n          'labels'  => {'role' => 'etcd'},\n        }],\n        'relabel_configs' => [{\n          'source_labels' => [],\n          'regex'         => '(.*)',\n          'target_label'  => '__param_target',\n          'replacement'   => \"https://127.0.0.1:${etcd_k8s_main_port}/metrics\",\n        }],\n      }\n    }\n\n    prometheus::scrape_config { 'etcd-k8s-events':\n      order  =>  150,\n      config => {\n        'metrics_path'    => '/probe',\n        'params'          => { 'module' => ['etcd_k8s_events_proxy'] },\n        'static_configs'  => [{\n          'targets' => $blackbox_exporters,\n          'labels'  => {'role' => 'etcd'},\n        }],\n        'relabel_configs' => [{\n          'source_labels' => [],\n          'regex'         => '(.*)',\n          'target_label'  => '__param_target',\n          'replacement'   => \"https://127.0.0.1:${etcd_k8s_events_port}/metrics\",\n        }],\n      }\n    }\n\n    prometheus::scrape_config { 'etcd-overlay':\n      order  =>  160,\n      config => {\n        'metrics_path'    => '/probe',\n        'params'          => { 'module' => ['etcd_overlay_proxy'] },\n        'static_configs'  => [{\n          'targets' => $blackbox_exporters,\n          'labels'  => {'role' => 'etcd'},\n        }],\n        'relabel_configs' => [{\n          'source_labels' => [],\n          'regex'         => '(.*)',\n          'target_label'  => '__param_target',\n          'replacement'   => \"https://127.0.0.1:${etcd_overlay_port}/metrics\",\n        }],\n      }\n    }\n\n    prometheus::rule { 'EtcdDown':\n      # TODO: we should limit this on the etcd jobs\n      expr        => '(probe_success !=1 AND probe_success{instance=~\".*etcd.*\"})',\n      for         => '2m',\n      summary     => '{{$labels.instance}}: etcd server probe failed',\n      description => '{{$labels.instance}}: etcd server probe failed for {{$labels.job}}',\n      order       => 10,\n    }\n\n    prometheus::rule { 'EtcdNoLeader':\n      # TODO: we should limit this on the etcd jobs\n      expr        => '(etcd_server_has_leader != 1)',\n      for         => '2m',\n      summary     => '{{$labels.instance}}: etcd server has no leader',\n      description => '{{$labels.instance}}: etcd cluster server has no leader',\n      order       => 10,\n    }\n  }\n\n  # Setup blackbox service on etcd nodes\n  if $::prometheus::role == 'etcd' {\n    $_download_url = regsubst($download_url, '#VERSION#' ,$version , 'G')\n\n    file { $dest_dir:\n      ensure => directory,\n      mode   => '0755',\n    }\n    -> archive { \"${dest_dir}/blackbox_exporter\":\n      ensure   => present,\n      extract  => false,\n      source   => $_download_url,\n      provider => 'airworthy',\n    }\n\n    file { $config_dir:\n      ensure => directory,\n      mode   => '0755',\n    }\n    -> file { \"${config_dir}/blackbox_exporter.yaml\":\n      ensure  => file,\n      content => template('prometheus/blackbox_exporter.yaml.erb'),\n    }\n\n    file { \"${systemd_path}/blackbox-exporter.service\":\n      ensure  => file,\n      content => template('prometheus/blackbox_exporter.service.erb'),\n    }\n    ~> exec { \"${module_name}-systemctl-daemon-reload\":\n      command     => '/usr/bin/systemctl daemon-reload',\n      refreshonly => true,\n    }\n\n    service { 'blackbox-exporter':\n      ensure    => running,\n      enable    => true,\n      subscribe => [\n        Archive[\"${dest_dir}/blackbox_exporter\"],\n        File[\"${config_dir}/blackbox_exporter.yaml\"],\n        File[\"${systemd_path}/blackbox-exporter.service\"]\n      ],\n    }\n  }\n}"
    },
    {
      "name": "prometheus::kube_state_metrics",
      "file": "manifests/kube_state_metrics.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "resizer_image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "resizer_version"
          }
        ]
      },
      "defaults": {
        "image": "'gcr.io/google_containers/kube-state-metrics'",
        "version": "'1.1.0'",
        "resizer_image": "'gcr.io/google_containers/addon-resizer'",
        "resizer_version": "'1.0'"
      },
      "source": "class prometheus::kube_state_metrics (\n  String $image = 'gcr.io/google_containers/kube-state-metrics',\n  String $version = '1.1.0',\n  String $resizer_image = 'gcr.io/google_containers/addon-resizer',\n  String $resizer_version = '1.0',\n){\n  require ::kubernetes\n  include ::prometheus\n\n  $namespace = $::prometheus::namespace\n\n  $authorization_mode = $::kubernetes::_authorization_mode\n  if member($authorization_mode, 'RBAC'){\n    $rbac_enabled = true\n  } else {\n    $rbac_enabled = false\n  }\n\n  if versioncmp($::kubernetes::version, '1.6.0') >= 0 {\n    $version_before_1_6 = false\n  } else {\n    $version_before_1_6 = true\n  }\n\n  kubernetes::apply{'kube-state-metrics':\n    manifests => [\n      template('prometheus/prometheus-ns.yaml.erb'),\n      template('prometheus/kube-state-metrics-deployment.yaml.erb'),\n      template('prometheus/kube-state-metrics-service.yaml.erb'),\n    ],\n  }\n\n  prometheus::rule { 'KubernetesPodUnready':\n    expr        => 'SUM((kube_pod_status_ready{condition=\"true\"} and ON(pod, namespace) kube_pod_status_phase{phase=\"Running\"})) WITHOUT (kubernetes_name, kubernetes_namespace, job, app, instance, condition) == 0',\n    for         => '5m',\n    summary     => '{{$labels.namespace}}/{{$labels.pod}}: pod is unready',\n    description => '{{$labels.namespace}}/{{$labels.pod}}: pod is unready',\n  }\n\n  prometheus::rule { 'KubernetesNodeUnready':\n    expr        => 'SUM(kube_node_status_condition{status=\"true\",condition=\"Ready\"} * ON(node) group_right kube_node_labels) WITHOUT (kubernetes_name, kubernetes_namespace, job, app, instance, condition) == 0',\n    for         => '5m',\n    summary     => '{{$labels.node}}: node is unready',\n    description => '{{$labels.node}}: node is unready {{$labels}}',\n  }\n}"
    },
    {
      "name": "prometheus::node_exporter",
      "file": "manifests/node_exporter.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "download_url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "sha256sums_url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "signature_url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Any"
            ],
            "name": "port"
          }
        ]
      },
      "defaults": {
        "image": "'prom/node-exporter'",
        "version": "'0.15.2'",
        "download_url": "'https://github.com/prometheus/node_exporter/releases/download/v#VERSION#/node_exporter-#VERSION#.linux-amd64.tar.gz'",
        "sha256sums_url": "'https://github.com/prometheus/node_exporter/releases/download/v#VERSION#/sha256sums.txt'",
        "signature_url": "'https://releases.tarmak.io/signatures/node_exporter/#VERSION#/sha256sums.txt.asc'",
        "port": "9100"
      },
      "source": "class prometheus::node_exporter (\n  String $image = 'prom/node-exporter',\n  String $version = '0.15.2',\n  String $download_url = 'https://github.com/prometheus/node_exporter/releases/download/v#VERSION#/node_exporter-#VERSION#.linux-amd64.tar.gz',\n  String $sha256sums_url = 'https://github.com/prometheus/node_exporter/releases/download/v#VERSION#/sha256sums.txt',\n  String $signature_url = 'https://releases.tarmak.io/signatures/node_exporter/#VERSION#/sha256sums.txt.asc',\n  $port = 9100,\n)\n{\n  include ::prometheus\n  $namespace = $::prometheus::namespace\n\n  $ignored_mount_points = '^/(sys|proc|dev|host|etc)($|/)'\n\n  # Setup deployment scrapes and rules for node_exporter\n  if $::prometheus::role == 'master' {\n    include ::prometheus::server\n    $kubernetes_token_file = $::prometheus::server::kubernetes_token_file\n    $kubernetes_ca_file = $::prometheus::server::kubernetes_ca_file\n\n    prometheus::rule { 'NodeHighCPUUsage':\n      expr        => '(100 - (avg(irate(node_cpu{mode=\"idle\"}[5m])) WITHOUT (cpu) * 100)) > 80',\n      for         => '5m',\n      summary     => '{{$labels.instance}}: High CPU usage detected',\n      description => '{{$labels.instance}}: CPU usage is above 80% (current value is: {{ $value }})',\n    }\n\n    prometheus::rule { 'NodeHighLoadAverage':\n      expr        => '((node_load5 / count without (cpu, mode) (node_cpu{mode=\"system\"})) > 3)',\n      for         => '5m',\n      summary     => '{{$labels.instance}}: High load average detected',\n      description => '{{$labels.instance}}: 5 minute load average is {{$value}}',\n    }\n\n    # TODO: Alert if diskspace is running out in x hours\n    prometheus::rule { 'NodeLowDiskSpace':\n      expr        => '((node_filesystem_size - node_filesystem_free ) / node_filesystem_size * 100) > 75',\n      for         => '2m',\n      summary     => '{{$labels.instance}}: Low disk space',\n      description => '{{$labels.instance}}: Disk usage is above 75% (current value is: {{ $value }}%)',\n    }\n\n    # TODO: Alert when swap is in use\n    prometheus::rule { 'NodeSwapEnabled':\n      expr        => '(((node_memory_SwapTotal-node_memory_SwapFree)/node_memory_SwapTotal)*100) > 75',\n      for         => '2m',\n      summary     => '{{$labels.instance}}: Swap usage detected',\n      description => '{{$labels.instance}}: Swap usage usage is above 75% (current value is: {{ $value }})',\n    }\n\n    prometheus::rule { 'NodeHighMemoryUsage':\n      expr        => '(((node_memory_MemTotal-node_memory_MemFree-node_memory_Cached)/(node_memory_MemTotal)*100)) > 80',\n      for         => '5m',\n      summary     => '{{$labels.instance}}: High memory usage detected',\n      description => '{{$labels.instance}}: Memory usage usage is above 80% (current value is: {{ $value }})',\n    }\n\n    # scrape node exporter running on every kubernetes node (through api proxy)\n    prometheus::scrape_config { 'kubernetes-nodes-exporter':\n      order  =>  130,\n      config => {\n        'kubernetes_sd_configs' => [{\n          'role' => 'node',\n        }],\n        'tls_config'            => {\n          'ca_file' => $kubernetes_ca_file,\n        },\n        'bearer_token_file'     => $kubernetes_token_file,\n        'scheme'                => 'https',\n        'relabel_configs'       => [{\n          'action' => 'labelmap',\n          'regex'  => '__meta_kubernetes_node_label_(.+)',\n          },{\n            'target_label' => '__address__',\n            'replacement'  => 'kubernetes.default.svc:443',\n            }, {\n              'source_labels' => ['__meta_kubernetes_node_name'],\n              'regex'         => '(.+)',\n              'target_label'  => '__metrics_path__',\n              'replacement'   => \"/api/v1/nodes/\\${1}:${port}/proxy/metrics\",\n            }],\n      }\n    }\n\n    # scrape node exporter running on etcd nodes\n    $etcd_node_exporters = $::prometheus::etcd_cluster.map |$node| { \"${node}:${port}\" }\n    prometheus::scrape_config { 'etcd-nodes-exporter':\n      order  =>  135,\n      config => {\n        'static_configs'  => [{\n          'targets' => $etcd_node_exporters,\n          'labels'  => {'role' => 'etcd'},\n        }],\n      }\n    }\n\n    kubernetes::apply{'node-exporter':\n      manifests => [\n        template('prometheus/prometheus-ns.yaml.erb'),\n        template('prometheus/node-exporter-ds.yaml.erb'),\n      ],\n    }\n  }\n\n  # Setup node_exporter service on etcd nodes\n  if $::prometheus::role == 'etcd' {\n    $_download_url = regsubst($download_url, '#VERSION#' ,$version , 'G')\n    $_signature_url = regsubst($signature_url, '#VERSION#' ,$version , 'G')\n    $_sha256sums_url = regsubst($sha256sums_url, '#VERSION#' ,$version , 'G')\n\n    $dest_dir = \"/opt/node_exporter-${version}\"\n    file { $dest_dir:\n      ensure => directory,\n      mode   => '0755',\n    }\n    -> archive { \"${dest_dir}/node_exporter.tar.gz\":\n      ensure            => present,\n      extract           => true,\n      extract_path      => $dest_dir,\n      extract_command   => 'tar xfz %s --strip-components=1',\n      source            => $_download_url,\n      sha256sums        => $_sha256sums_url,\n      signature_armored => $_signature_url,\n      provider          =>  'airworthy',\n    }\n    -> file { \"${::prometheus::systemd_path}/node-exporter.service\":\n      ensure  => file,\n      content => template('prometheus/node-exporter.service.erb'),\n      notify  => Exec[\"${module_name}-systemctl-daemon-reload\"],\n    }\n    -> service { 'node-exporter':\n      ensure => running,\n      enable => true,\n    }\n  }\n}"
    },
    {
      "name": "prometheus::params",
      "file": "manifests/params.pp",
      "line": 1,
      "docstring": {
        "text": ""
      },
      "source": "class prometheus::params {\n  if defined('::tarmak') {\n    $etcd_cluster         = $::tarmak::_etcd_cluster\n    $etcd_k8s_main_port   = $::tarmak::etcd_k8s_main_client_port\n    $etcd_k8s_events_port = $::tarmak::etcd_k8s_events_client_port\n    $etcd_overlay_port    = $::tarmak::etcd_overlay_client_port\n    $role                 = $::tarmak::role\n  } else {\n    $etcd_cluster         = undef\n    $etcd_k8s_main_port   = 2379\n    $etcd_k8s_events_port = 2369\n    $etcd_overlay_port    = 2359\n    $role                 = undef\n  }\n}"
    },
    {
      "name": "prometheus::server",
      "file": "manifests/server.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "reloader_image"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "reloader_version"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "retention"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer[1025,65535]"
            ],
            "name": "port"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "external_url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Boolean"
            ],
            "name": "persistent_volume"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "persistent_volume_size"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "kubernetes_token_file"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "kubernetes_ca_file"
          }
        ]
      },
      "defaults": {
        "image": "'prom/prometheus'",
        "version": "'2.2.1'",
        "reloader_image": "'jimmidyson/configmap-reload'",
        "reloader_version": "'0.1'",
        "retention": "'720h'",
        "port": "9090",
        "external_url": "''",
        "persistent_volume": "false",
        "persistent_volume_size": "15",
        "kubernetes_token_file": "'/var/run/secrets/kubernetes.io/serviceaccount/token'",
        "kubernetes_ca_file": "'/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'"
      },
      "source": "class prometheus::server (\n  String $image = 'prom/prometheus',\n  String $version = '2.2.1',\n  String $reloader_image = 'jimmidyson/configmap-reload',\n  String $reloader_version = '0.1',\n  String $retention = '720h',  # 30 days\n  Integer[1025,65535] $port = 9090,\n  String $external_url = '',\n  Boolean $persistent_volume = false,\n  Integer $persistent_volume_size = 15,\n  String $kubernetes_token_file = '/var/run/secrets/kubernetes.io/serviceaccount/token',\n  String $kubernetes_ca_file = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt',\n)\n{\n  require ::kubernetes\n  include ::prometheus\n\n  $namespace = $::prometheus::namespace\n\n  $authorization_mode = $::kubernetes::_authorization_mode\n  if member($authorization_mode, 'RBAC'){\n    $rbac_enabled = true\n  } else {\n    $rbac_enabled = false\n  }\n\n  if versioncmp($::kubernetes::version, '1.6.0') >= 0 {\n    $version_before_1_6 = false\n  } else {\n    $version_before_1_6 = true\n  }\n\n  kubernetes::apply{'prometheus-server':\n    manifests => [\n      template('prometheus/prometheus-ns.yaml.erb'),\n      template('prometheus/prometheus-deployment.yaml.erb'),\n      template('prometheus/prometheus-svc.yaml.erb'),\n    ],\n  }\n\n  kubernetes::apply{'prometheus-config':\n      type => 'concat',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-config-header':\n      content => template('prometheus/prometheus-config-header.yaml.erb'),\n      order   => 0,\n      target  => 'prometheus-config',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-config-prometheus-file':\n      content => '  prometheus.yaml: |-',\n      order   => 100,\n      target  => 'prometheus-config',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-config-prometheus-rules':\n      content => template('prometheus/prometheus-config-rules.yaml.erb'),\n      order   => 200,\n      target  => 'prometheus-config',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-config-global':\n      content => template('prometheus/prometheus-config-global.yaml.erb'),\n      order   => 300,\n      target  => 'prometheus-config',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-config-global-pre-scrape-config':\n      content => '    scrape_configs:',\n      order   => 400,\n      target  => 'prometheus-config',\n  }\n\n\n  # Scrape config for API servers.\n  #\n  # Kubernetes exposes API servers as endpoints to the default/kubernetes\n  # service so this uses `endpoints` role and uses relabelling to only keep\n  # the endpoints associated with the default/kubernetes service using the\n  # default named port `https`. This works for single API server deployments as\n  # well as HA API server deployments.\n  prometheus::scrape_config { 'kubernetes-apiservers':\n    order  =>  100,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'endpoints',\n      }],\n      'tls_config'            => {\n        'ca_file' => $kubernetes_ca_file,\n      },\n      'bearer_token_file'     => $kubernetes_token_file,\n      'scheme'                => 'https',\n      'relabel_configs'       => [{\n        'source_labels' => ['__meta_kubernetes_namespace', '__meta_kubernetes_service_name', '__meta_kubernetes_endpoint_port_name'],\n        'action'        => 'keep',\n        'regex'         => 'default;kubernetes;https',\n      }],\n    }\n  }\n\n  # Scrape config for nodes (kubelet).\n  #\n  # Rather than connecting directly to the node, the scrape is proxied though the\n  # Kubernetes apiserver.  This means it will work if Prometheus is running out of\n  # cluster, or can't connect to nodes for some other reason (e.g. because of\n  # firewalling).\n  prometheus::scrape_config { 'kubernetes-nodes':\n    order  =>  110,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'node',\n      }],\n      'tls_config'            => {\n        'ca_file' => $kubernetes_ca_file,\n      },\n      'bearer_token_file'     => $kubernetes_token_file,\n      'scheme'                => 'https',\n      'relabel_configs'       => [{\n        'action' => 'labelmap',\n        'regex'  => '__meta_kubernetes_node_label_(.+)',\n      },{\n        'target_label' => '__address__',\n        'replacement'  => 'kubernetes.default.svc:443',\n      }, {\n        'source_labels' => ['__meta_kubernetes_node_name'],\n        'regex'         => '(.+)',\n        'target_label'  => '__metrics_path__',\n        'replacement'   => '/api/v1/nodes/${1}/proxy/metrics',\n      }],\n    }\n  }\n\n\n  # Scrape config for Kubelet cAdvisor.\n  #\n  # This is required for Kubernetes 1.7.3 and later, where cAdvisor metrics\n  # (those whose names begin with 'container_') have been removed from the\n  # Kubelet metrics endpoint.  This job scrapes the cAdvisor endpoint to\n  # retrieve those metrics.\n  #\n  # In Kubernetes 1.7.0-1.7.2, these metrics are only exposed on the cAdvisor\n  # HTTP endpoint; use \"replacement: /api/v1/nodes/${1}:4194/proxy/metrics\"\n  # in that case (and ensure cAdvisor's HTTP server hasn't been disabled with\n  # the --cadvisor-port=0 Kubelet flag).\n  #\n  # This job is not necessary and should be removed in Kubernetes 1.6 and\n  # earlier versions, or it will cause the metrics to be scraped twice.\n  prometheus::scrape_config { 'kubernetes-nodes-cadvisor':\n    order  =>  120,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'node',\n      }],\n      'tls_config'            => {\n        'ca_file' => $kubernetes_ca_file,\n      },\n      'bearer_token_file'     => $kubernetes_token_file,\n      'scheme'                => 'https',\n      'relabel_configs'       => [{\n        'action' => 'labelmap',\n        'regex'  => '__meta_kubernetes_node_label_(.+)',\n      },{\n        'target_label' => '__address__',\n        'replacement'  => 'kubernetes.default.svc:443',\n      }, {\n        'source_labels' => ['__meta_kubernetes_node_name'],\n        'regex'         => '(.+)',\n        'target_label'  => '__metrics_path__',\n        'replacement'   => '/api/v1/nodes/${1}/proxy/metrics/cadvisor',\n      }],\n    }\n  }\n\n  # Scrape config for service endpoints.\n  #\n  # The relabeling allows the actual service scrape endpoint to be configured\n  # via the following annotations:\n  #\n  # * `prometheus.io/scrape`: Only scrape services that have a value of `true`\n  # * `prometheus.io/scheme`: If the metrics endpoint is secured then you will need\n  # to set this to `https` & most likely set the `tls_config` of the scrape config.\n  # * `prometheus.io/path`: If the metrics path is not `/metrics` override this.\n  # * `prometheus.io/port`: If the metrics are exposed on a different port to the\n  # service then set this appropriately.\n  prometheus::scrape_config { 'kubernetes-service-endpoints':\n    order  =>  200,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'endpoints',\n      }],\n\n      'relabel_configs'       => [\n        {\n          'source_labels' => ['__meta_kubernetes_service_annotation_prometheus_io_scrape'],\n          'action'        => 'keep',\n          'regex'         => true,\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_service_annotation_prometheus_io_scheme'],\n          'action'        => 'replace',\n          'target_label'  => '__scheme__',\n          'regex'         => '(https?)',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_service_annotation_prometheus_io_path'],\n          'action'        => 'replace',\n          'target_label'  => '__metrics_path__',\n          'regex'         => '(.+)',\n        },\n        {\n          'source_labels' => ['__address__', '__meta_kubernetes_service_annotation_prometheus_io_port'],\n          'action'        => 'replace',\n          'target_label'  => '__address__',\n          'regex'         => '(.+)(?::\\d+);(\\d+)',\n          'replacement'   => '$1:$2',\n        },\n        {\n          'action' => 'labelmap',\n          'regex'  => '__meta_kubernetes_service_label_(.+)',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_namespace'],\n          'action'        => 'replace',\n          'target_label'  => 'kubernetes_namespace',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_service_name'],\n          'action'        => 'replace',\n          'target_label'  => 'kubernetes_name',\n        }\n      ]\n    }\n  }\n\n  # Example scrape config for probing services via the Blackbox Exporter.\n  #\n  # The relabeling allows the actual service scrape endpoint to be configured\n  # via the following annotations:\n  #\n  # * `prometheus.io/probe`: Only probe services that have a value of `true`\n  prometheus::scrape_config { 'kubernetes-services':\n    order  =>  210,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'service'\n      }],\n      'metrics_path'          => '/probe',\n      'params'                => {\n        'module' => ['http_2xx'],\n      },\n      'relabel_configs'       => [\n        {\n          'source_labels' => ['__meta_kubernetes_service_annotation_prometheus_io_probe'],\n          'action'        => 'keep',\n          'regex'         => true,\n        },\n        {\n          'source_labels' => ['__address__'],\n          'target_label'  => '__param_target',\n        },\n        {\n          'target_label' => '__address__',\n          'replacement'  => 'blackbox-exporter',\n        },\n        {\n          'source_labels' => ['__param_target'],\n          'target_label'  => 'instance',\n        },\n        {\n          'action' => 'labelmap',\n          'regex'  => '__meta_kubernetes_service_label_(.+)',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_service_namespace'],\n          'target_label'  => 'kubernetes_namespace',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_service_name'],\n          'target_label'  => 'kubernetes_name',\n        },\n      ]\n    },\n  }\n\n\n  # Example scrape config for probing ingresses via the Blackbox Exporter.\n  #\n  # The relabeling allows the actual ingress scrape endpoint to be configured\n  # via the following annotations:\n  #\n  # * `prometheus.io/probe`: Only probe ingresses that have a value of `true`\n  prometheus::scrape_config { 'kubernetes-ingresses':\n    order  =>  220,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'ingress'\n      }],\n      'metrics_path'          => '/probe',\n      'params'                => {\n        'module' => ['http_2xx'],\n      },\n      'relabel_configs'       => [\n        {\n          'source_labels' => ['__meta_kubernetes_ingress_annotation_prometheus_io_probe'],\n          'action'        => 'keep',\n          'regex'         => true,\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_ingress_scheme','__address__','__meta_kubernetes_ingress_path'],\n          'target_label'  => '__param_target',\n          'regex'         => '(.+);(.+);(.+)',\n          'replacement'   => '${1}://${2}${3}',\n        },\n        {\n          'target_label' => '__address__',\n          'replacement'  => 'blackbox-exporter',\n        },\n        {\n          'source_labels' => ['__param_target'],\n          'target_label'  => 'instance',\n        },\n        {\n          'action' => 'labelmap',\n          'regex'  => '__meta_kubernetes_ingress_label_(.+)',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_ingress_namespace'],\n          'target_label'  => 'kubernetes_namespace',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_ingress_name'],\n          'target_label'  => 'kubernetes_name',\n        },\n      ]\n    },\n  }\n\n  # Example scrape config for pods\n  #\n  # The relabeling allows the actual pod scrape endpoint to be configured via the\n  # following annotations:\n  #\n  # * `prometheus.io/scrape`: Only scrape pods that have a value of `true`\n  # * `prometheus.io/path`: If the metrics path is not `/metrics` override this.\n  # * `prometheus.io/port`: Scrape the pod on the indicated port instead of the\n  # pod's declared ports (default is a port-free target if none are declared).\n  prometheus::scrape_config { 'kubernetes-pods':\n    order  =>  230,\n    config => {\n      'kubernetes_sd_configs' => [{\n        'role' => 'pod'\n      }],\n      'relabel_configs'       => [\n        {\n          'source_labels' => ['__meta_kubernetes_pod_annotation_prometheus_io_scrape'],\n          'action'        => 'keep',\n          'regex'         => true,\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_pod_annotation_prometheus_io_path'],\n          'action'        => 'replace',\n          'target_label'  => '__metrics_path__',\n          'regex'         => '(.+)',\n        },\n        {\n          'source_labels' => ['__address__', '__meta_kubernetes_pod_annotation_prometheus_io_port'],\n          'action'        => 'replace',\n          'regex'         => '([^:]+)(?::\\d+)?;(\\d+)',\n          'replacement'   => '${1}:${2}',\n          'target_label'  => '__address__',\n        },\n        {\n          'action' => 'labelmap',\n          'regex'  => '__meta_kubernetes_pod_label_(.+)',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_namespace'],\n          'action'        => 'replace',\n          'target_label'  => 'kubernetes_namespace',\n        },\n        {\n          'source_labels' => ['__meta_kubernetes_pod_name'],\n          'action'        => 'replace',\n          'target_label'  => 'kubernetes_pod_name',\n        }\n      ]\n    }\n  }\n\n  kubernetes::apply{'prometheus-rules':\n      type => 'concat',\n  }\n\n  kubernetes::apply_fragment { 'prometheus-rules-header':\n      content => template('prometheus/prometheus-rules-header.yaml.erb'),\n      order   => 0,\n      target  => 'prometheus-rules',\n  }\n\n\n  prometheus::rule { 'ScrapeEndpointDown':\n    expr        => '(up == 0 AND up {job != \"kubernetes-apiservers\"})',\n    for         => '2m',\n    summary     => '{{$labels.instance}}: Scrape target is down',\n    description => '{{$labels.instance}}: Target down for job {{$labels.job}}',\n  }\n\n  prometheus::rule { 'ContainerScrapeError':\n    expr        => '(container_scrape_error) != 0',\n    for         => '2m',\n    summary     => '{{$labels.instance}}: Container scrape error',\n    description => '{{$labels.instance}}: Failed to scrape container, metrics will not be updated',\n  }\n}"
    }
  ],
  "defined_types": [
    {
      "name": "prometheus::rule",
      "file": "manifests/rule.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "expr"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "summary"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "description"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "for"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Any"
            ],
            "name": "labels"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "order"
          }
        ]
      },
      "defaults": {
        "for": "'5m'",
        "labels": "{'severity' => 'page'}",
        "order": "10"
      },
      "source": "define prometheus::rule (\n  String $expr,\n  String $summary,\n  String $description,\n  String $for = '5m',\n  $labels = {'severity' => 'page'},\n  Integer $order = 10,\n) {\n  if ! defined(Class['kubernetes::apiserver']) {\n    fail('This defined type can only be used on the kubernetes master')\n  }\n\n  $config = {\n    'groups' =>  [{\n      'name'  => $name,\n      'rules' =>  [\n        {\n          'alert'       => $name,\n          'expr'        => $expr,\n          'for'         => $for,\n          'labels'      => $labels,\n          'annotations' => {\n            'summary'     => $summary,\n            'description' => $description,\n          }\n        }\n      ]\n    }]\n  }\n\n\n  kubernetes::apply_fragment { \"prometheus-rules-${title}\":\n    content => template('prometheus/prometheus-rule.yaml.erb'),\n    order   => $order,\n    target  => 'prometheus-rules',\n  }\n}"
    },
    {
      "name": "prometheus::scrape_config",
      "file": "manifests/scrape_config.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Integer"
            ],
            "name": "order"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Any"
            ],
            "name": "config"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "Any"
            ],
            "name": "job_name"
          }
        ]
      },
      "defaults": {
        "config": "{}",
        "job_name": "$title"
      },
      "source": "define prometheus::scrape_config (\n  Integer $order,\n  $config = {},\n  $job_name = $title,\n) {\n  if ! defined(Class['kubernetes::apiserver']) {\n    fail('This defined type can only be used on the kubernetes master')\n  }\n\n  kubernetes::apply_fragment { \"prometheus-scrape-config-${job_name}\":\n    content => template('prometheus/prometheus-config-frag.yaml.erb'),\n    order   => 400 + $order,\n    target  => 'prometheus-config',\n  }\n}"
    },
    {
      "name": "prometheus::wget_file",
      "file": "manifests/wget_file.pp",
      "line": 1,
      "docstring": {
        "text": "",
        "tags": [
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "url"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "destination_dir"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "destination_file"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "user"
          },
          {
            "tag_name": "param",
            "text": "",
            "types": [
              "String"
            ],
            "name": "umask"
          }
        ]
      },
      "defaults": {
        "destination_file": "''",
        "user": "'root'",
        "umask": "'022'"
      },
      "source": "define prometheus::wget_file(\n  String $url,\n  String $destination_dir,\n  String $destination_file = '',\n  String $user = 'root',\n  String $umask = '022',\n)\n{\n\n  ensure_packages([ 'wget' ])\n\n  if \"x${destination_file}x\" == 'xx' {\n    $filename = regsubst($url, '^http.*\\/([^\\/]+)$', '\\1')\n  } else {\n    $filename = $destination_file\n  }\n\n  exec { \"download-${filename}\":\n    command => \"/usr/bin/wget -O ${filename} ${url}\",\n    cwd     => $destination_dir,\n    creates => \"${destination_dir}/${filename}\",\n    user    => $user,\n    umask   => $umask,\n    require => Package['wget'],\n    }\n}"
    }
  ],
  "resource_types": [

  ],
  "providers": [

  ],
  "puppet_functions": [
    {
      "name": "fragmenthash2yaml",
      "file": "lib/puppet/parser/functions/fragmenthash2yaml.rb",
      "line": 2,
      "type": "ruby3x",
      "signatures": [
        {
          "signature": "fragmenthash2yaml()",
          "docstring": {
            "text": "This converts a puppet hash to YAML string for a concat fragment.",
            "tags": [
              {
                "tag_name": "return",
                "text": "",
                "types": [
                  "Any"
                ]
              }
            ]
          }
        }
      ],
      "docstring": {
        "text": "This converts a puppet hash to YAML string for a concat fragment.",
        "tags": [
          {
            "tag_name": "return",
            "text": "",
            "types": [
              "Any"
            ]
          }
        ]
      },
      "source": "newfunction(:fragmenthash2yaml, :type => :rvalue, :doc => <<-EOS\nThis converts a puppet hash to YAML string for a concat fragment.\n  EOS\n) do |arguments|\n  require 'yaml'\n\n  if arguments.size != 1\n    raise(Puppet::ParseError, 'fragmenthash2yaml(): requires one and only one argument')\n  end\n  unless arguments[0].is_a?(Hash)\n    raise(Puppet::ParseError, 'fragmenthash2yaml(): requires a hash as argument')\n  end\n\n  h = arguments[0]\n  # https://github.com/hallettj/zaml/issues/3\n  # https://tickets.puppetlabs.com/browse/PUP-3120\n  # https://tickets.puppetlabs.com/browse/PUP-5630\n  #\n  # puppet 3.x uses ZAML which formats YAML output differently than puppet 4.x\n  # including not ending the file with a new line\n  if Puppet.version.to_f < 4.0\n    return h.to_yaml.gsub(/---\\n/, '') << \"\\n\"\n  else\n    return h.to_yaml.gsub(/---\\n/, '')\n  end\nend"
    }
  ]
}
